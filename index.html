<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f1a" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" type="image/svg+xml" sizes="any" href="icons/punchbuggy.svg" />
  <title>Punch Buggy — Mobile</title>
  <style>
    :root{
      --bg: #0b0f1a;
      --panel: #121829ee;
      --panel-2: #0f1524aa;
      --text: #e6ecff;
      --muted: #97a3c0;
      --accent: #5be2b0;
      --accent-2:#8aa8ff;
      --danger: #ff6b6b;
      --gold: #ffd166;
      --shadow: 0 6px 20px rgba(0,0,0,.35);
      --radius: 16px;
      --update-banner-offset: 0px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui,Roboto,Arial,sans-serif;
      color:var(--text); background: var(--bg);
      display:flex; flex-direction:column; padding:12px; padding-top:calc(12px + var(--update-banner-offset, 0px)); gap:12px;
    }

    header{
      text-align:center; font-weight:800; font-size:22px; padding:8px;
      position:relative;
    }

    .version-tag{
      position:absolute; right:12px; top:12px; font-size:12px; font-weight:600;
      padding:4px 8px; border-radius:999px; background:rgba(255,255,255,0.08);
      color:var(--muted); box-shadow:0 2px 6px rgba(0,0,0,0.3);
    }

    .update-banner{
      position:fixed; top:12px; top:calc(env(safe-area-inset-top, 0px) + 12px); z-index:100;
      left:50%; transform:translateX(-50%);
      width:calc(100% - 24px); max-width:520px;
      display:none; flex-direction:column; align-items:stretch;
      padding:14px 16px; border-radius:14px; background:linear-gradient(135deg,#12213f,#102542);
      box-shadow:0 8px 24px rgba(0,0,0,0.45); gap:12px;
    }

    .update-banner strong{ font-size:14px; display:block; }

    .update-actions{ display:flex; gap:8px; flex-wrap:wrap; width:100%; }

    .update-banner button{
      padding:12px 16px; border-radius:999px; border:none; cursor:pointer; font-weight:700;
      background:linear-gradient(180deg,#22c997,#1aa97a); color:#fff; flex:1 1 140px;
    }

    .update-banner .ghost{
      background:transparent; border:1px solid rgba(91,226,176,0.5); color:var(--muted);
    }

    @media (min-width: 520px){
      .update-banner{
        flex-direction:row; align-items:center;
      }
      .update-banner strong{ font-size:15px; }
      .update-actions{ width:auto; flex-wrap:nowrap; }
      .update-banner button{ flex:0 0 auto; padding:10px 20px; }
    }

    .backup-panel{
      margin-top:16px; padding:12px; border-radius:12px;
      background:linear-gradient(180deg,rgba(15,22,40,0.9),rgba(12,19,34,0.9));
      display:flex; flex-direction:column; gap:10px;
    }

    .backup-panel h4{ margin:0; font-size:14px; text-transform:uppercase; letter-spacing:0.08em; color:var(--muted); }
    .backup-status{ font-size:14px; line-height:1.4; color:var(--text); }
    .backup-meta{ font-size:12px; color:var(--muted); }
    .backup-actions{ display:flex; gap:8px; flex-wrap:wrap; }
    .backup-actions button{ flex:1; min-width:140px; font-size:14px; padding:10px; }
    .backup-toggle{ display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted); }
    .backup-toggle input{ width:18px; height:18px; }

    .players{ display:flex; flex-direction:column; gap:14px; flex:1 }
    .card{
      background:linear-gradient(160deg,var(--panel),var(--panel-2));
      border-radius:var(--radius); box-shadow:var(--shadow);
      padding:14px; display:flex; flex-direction:column; align-items:center; gap:10px;
    }
    .avatar-wrapper{ position:relative; display:inline-block }
    .avatar{
      width:100px; height:100px; border-radius:50%; border:2px solid #2f4170;
      object-fit:cover; cursor:pointer; position:relative; transition: transform .2s
    }
      .player-crown{ position:absolute; top:-6px; right:-6px; width:28px; height:28px; display:none; align-items:center; justify-content:center; font-size:18px; background:linear-gradient(180deg,#ffd166,#ffb347); color:#2b180d; border-radius:50%; box-shadow:0 6px 18px rgba(0,0,0,0.35); border:2px solid rgba(255,255,255,0.12) }
    .avatar:hover{ transform: scale(1.05) }
    .upload-label{
      position:absolute; bottom:0; right:0; background:#22c997; color:#fff;
      border-radius:50%; width:32px; height:32px; display:flex; align-items:center;
      justify-content:center; cursor:pointer; font-size:18px; box-shadow:0 2px 8px rgba(0,0,0,.3)
    }
    .upload-label svg{
      width:18px; height:18px; display:block;
    }
    .upload-input{ display:none }
    .name{
      font-size:20px; font-weight:700; text-align:center; background:transparent;
      border:none; outline:none; color:var(--text); margin:4px 0
    }
    .score{ font-size:42px; font-weight:900; transition: transform .3s, color .3s }
    .score.bump{ animation: scoreBump .5s ease }
    .streak{ font-size:14px; color:var(--muted) }

    @keyframes scoreBump{ 0%,100%{transform:scale(1)} 50%{transform:scale(1.2)} }
    @keyframes shake{ 0%,100%{transform:translateX(0)} 25%{transform:translateX(-8px)} 75%{transform:translateX(8px)} }
    .card.winner{ animation: winPulse .6s ease }
    .card.loser{ animation: shake .5s ease }
    @keyframes winPulse{ 0%,100%{transform:scale(1)} 50%{transform:scale(1.03)} }

    button{
      width:100%; padding:16px; font-size:18px; font-weight:700;
      border:none; border-radius:var(--radius); cursor:pointer;
    }
    .accent{ background:linear-gradient(180deg,#22c997,#1aa97a); color:#fff }
    .danger{ background:linear-gradient(180deg,#ff7c7c,#ff4d4d); color:#fff }
    .ghost{ background:transparent; border:1px solid #2a3966; color:var(--text) }

    .roundbar{
      text-align:center; font-weight:700; padding:10px;
      border-radius:var(--radius); background:#111832;
    }

    .log{
      flex:1; overflow:auto; background:#0b1226; border-radius:var(--radius);
      padding:10px; font-size:13px
    }
    .log h3{ margin:0 0 6px 0; font-size:12px; color:var(--muted) }
    .log ul{
      list-style:none; margin:0; padding:0; display:flex;
      flex-direction:column; gap:6px
    }
    .log li{ padding:6px 8px; border-radius:8px; background:rgba(255,255,255,.05) }

    .toolbar{ display:grid; grid-template-columns:repeat(3,1fr); gap:8px }

    @media(min-width:700px){ body{ max-width:420px; margin:0 auto } }

    .confetti{ position:fixed; inset:0; pointer-events:none; }
    .piece{ position:absolute; width:8px; height:12px }

    /* Leaderboard styles */
    .leaderboard-wrap{ display:none; position:fixed; left:12px; right:12px; bottom:80px; z-index:40 }
    .leaderboard{ display:flex; gap:8px; justify-content:space-between; align-items:center; padding:10px; border-radius:12px; background:linear-gradient(180deg,#081025, #0f1726); box-shadow:var(--shadow)}
    .leaderboard .col{ display:flex; flex-direction:column; align-items:center; gap:8px; min-width:120px }
    .leaderboard h4{ margin:0; font-size:12px; color:var(--muted) }
    .tokens{ display:flex; gap:6px; flex-wrap:wrap; justify-content:center }
    .token{ width:20px; height:20px; border-radius:4px; display:inline-grid; place-items:center; font-size:12px; font-weight:800; color:#071024 }
    .token.win{ background:var(--gold); color:#081025; box-shadow:0 4px 10px rgba(255,209,102,.12) }
    .token.lose{ background:transparent; border:2px solid rgba(255,255,255,.06); color:var(--muted); position:relative }
    .token.lose::after{ content:''; position:absolute; left:-6px; right:-6px; top:50%; height:2px; background:linear-gradient(90deg,transparent,rgba(255,255,255,.18),transparent); transform:rotate(-12deg) }
    .leader-actions{ display:flex; gap:8px }

    @media(min-width:700px){ .leaderboard-wrap{ left:50%; transform:translateX(-50%); width:420px } }
  /* Fullscreen leaderboard view */
  .leaderboard-view{
    display:none; position:fixed; inset:0; z-index:60;
    background: linear-gradient(135deg, #0a0e1a 0%, #0f1524 50%, #071024 100%);
    padding:20px; overflow:auto; backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.1);
  }
  .leaderboard-view .view-header{
    display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:20px;
    padding:16px 20px; background: rgba(255,255,255,0.05); border-radius:16px;
    border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }
    .view-title{
    font-weight:900; font-size:20px; color: var(--accent); text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    flex:1; text-align:center;
  }
    /* App title styling */
    .app-title{ display:flex; flex-direction:column; align-items:center; gap:4px }
  .title-main{ font-weight:900; font-size:28px; background:linear-gradient(90deg,var(--accent),var(--accent-2)); -webkit-background-clip:text; background-clip:text; color:transparent; text-shadow: 0 6px 18px rgba(10,12,24,0.6); }
  .back-btn{
    padding:10px 16px; border-radius:12px; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    border: 1px solid rgba(255,255,255,0.15); color:var(--text); font-weight:700;
    transition: all 0.2s ease; cursor:pointer;
  }
  .back-btn:hover{ background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1)); transform: scale(1.05); }
  .leaderboard-summary{
    text-align:center; margin-bottom:16px; font-size:18px; font-weight:600; color:var(--text);
    background: rgba(255,255,255,0.05); padding:12px; border-radius:12px;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .leaderboard-grid{ display:flex; gap:20px; flex-direction:column }
  @media(min-width:700px){ .leaderboard-grid{ flex-direction:row } }
  .leaderboard-col{
    flex:1; background: linear-gradient(135deg, rgba(11,18,38,0.9), rgba(7,16,34,0.9));
    padding:20px; border-radius:16px; border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 12px 40px rgba(0,0,0,0.4); transition: transform 0.2s ease;
  }
  .leaderboard-col:hover{ transform: translateY(-2px); }
  .leaderboard-col h4{ margin:0 0 12px 0; font-size:16px; color:var(--accent); text-align:center; font-weight:700; display:block; width:100%; }
  .leaderboard-col { text-align:center }
  .tokens-full{ display:flex; flex-wrap:wrap; gap:12px; justify-content:center }
  .token.full{
    width:48px; height:48px; border-radius:8px; display:inline-grid; place-items:center; font-size:16px; font-weight:800;
    transition: all 0.2s ease; cursor:default;
  }
  .token.full.win{
    background: linear-gradient(135deg, #ffd166, #ffb347); color:#2d1b0f;
    box-shadow: 0 4px 12px rgba(255,209,102,0.3); border: 2px solid rgba(255,255,255,0.2);
  }
  .token.full.lose{
    background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    border: 2px solid rgba(255,255,255,0.1); color:var(--muted);
    position:relative;
  }
  .token.full.lose::after{
    content:''; position:absolute; left:-8px; right:-8px; top:50%; height:3px;
    background: linear-gradient(90deg, transparent, rgba(255,107,107,0.6), transparent);
    transform: rotate(-15deg); border-radius: 2px;
  }
  .token.full:hover{ transform: scale(1.1); }
  .avatar-sm{ width:46px; height:46px; border-radius:8px; overflow:hidden; position:relative }
  .avatar-sm img{ width:100%; height:100%; object-fit:cover; display:block }
  .crown{ position:absolute; top:-6px; right:-6px; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-size:12px; background:linear-gradient(180deg,#ffd166,#ffb347); color:#2b180d; border-radius:50%; box-shadow:0 6px 12px rgba(0,0,0,0.25); border:1px solid rgba(255,255,255,0.12) }
  /* Modals */
  .modal{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:80; background:linear-gradient(180deg, rgba(2,6,12,0.6), rgba(2,6,12,0.85)); }
  .modal-card{ width:calc(100% - 48px); max-width:720px; padding:16px; border-radius:14px; box-shadow:0 12px 48px rgba(0,0,0,0.6); }
  @media(min-width:700px){ .modal-card{ padding:24px } }
  </style>  
</head>
<body>
  <header>
    <div class="app-title">
      <div class="title-main">Punch Buggy</div>
    </div>
    <span class="version-tag">v<span id="appVersion">—</span></span>
  </header>

  <div class="players">
    <div class="card" data-player="A">
      <div class="avatar-wrapper">
  <img class="avatar" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><rect width='100%' height='100%' fill='%2316273a'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='Verdana,Arial' font-size='72' fill='%23ffffff'>A</text></svg>" alt="Player A" id="avatarA" onerror="this.src='data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'200\'><rect width=\'100%\' height=\'100%\' fill=\'%2316273a\'/><text x=\'50%\' y=\'50%\' dominant-baseline=\'middle\' text-anchor=\'middle\' font-family=\'Verdana,Arial\' font-size=\'72\' fill=\'%23ffffff\'>A</text></svg>'">
        <span class="player-crown" id="crownA">👑</span>
        <label class="upload-label" for="uploadA" aria-label="Change Player A avatar">
          <svg class="upload-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor" d="M4 6h3l1-1h8l1 1h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2zm8 3.5a4.5 4.5 0 1 0 4.5 4.5A4.5 4.5 0 0 0 12 9.5zm0 1.5a3 3 0 1 1-3 3 3 3 0 0 1 3-3z"/>
          </svg>
        </label>
        <input type="file" class="upload-input" id="uploadA" accept="image/*">
      </div>
      <input class="name" id="nameA" value="Player A">
      <div class="score" id="scoreA">0</div>
      <div class="streak" id="streakA">🔥 0</div>
      <button class="accent" id="btnA">+1 Punch</button>
      <button class="ghost" id="minusA">−1</button>
    </div>

    <div class="card" data-player="B">
      <div class="avatar-wrapper">
  <img class="avatar" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><rect width='100%' height='100%' fill='%2316273a'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='Verdana,Arial' font-size='72' fill='%23ffffff'>B</text></svg>" alt="Player B" id="avatarB" onerror="this.src='data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'200\'><rect width=\'100%\' height=\'100%\' fill=\'%2316273a\'/><text x=\'50%\' y=\'50%\' dominant-baseline=\'middle\' text-anchor=\'middle\' font-family=\'Verdana,Arial\' font-size=\'72\' fill=\'%23ffffff\'>B</text></svg>'">
        <span class="player-crown" id="crownB">👑</span>
        <label class="upload-label" for="uploadB" aria-label="Change Player B avatar">
          <svg class="upload-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor" d="M4 6h3l1-1h8l1 1h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2zm8 3.5a4.5 4.5 0 1 0 4.5 4.5A4.5 4.5 0 0 0 12 9.5zm0 1.5a3 3 0 1 1-3 3 3 3 0 0 1 3-3z"/>
          </svg>
        </label>
        <input type="file" class="upload-input" id="uploadB" accept="image/*">
      </div>
      <input class="name" id="nameB" value="Player B">
      <div class="score" id="scoreB">0</div>
      <div class="streak" id="streakB">🔥 0</div>
      <button class="accent" id="btnB">+1 Punch</button>
      <button class="ghost" id="minusB">−1</button>
    </div>
  </div>

  <div class="roundbar">Round <span id="round">1</span> • <span id="lead">Tied</span></div>

  <div class="toolbar">
    <button class="ghost" id="undoBtn">↶ Undo</button>
    <button class="danger" id="resetBtn">⟳ Reset</button>
    <button class="ghost" id="nextRound">Next Round ▶</button>
  <button class="ghost" id="leaderboardBtn">🏆 Scores</button>
    <button class="ghost" id="dataBtn">&#x1F4BE; Data</button>
    <button class="ghost" id="rulesBtn">❓ Rules</button>
  </div>

  <!-- Event log moved to Data modal -->

  <div class="confetti" id="confetti"></div>

  <!-- Leaderboard (hidden by default) -->
  <div class="leaderboard-wrap" id="leaderboardWrap">
    <div class="leaderboard card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
  <div style="font-weight:800">Scores</div>
        <div>
          <button class="ghost" id="clearBoard">Clear</button>
          <button class="ghost" id="closeBoard">Close</button>
        </div>
      </div>
      <div id="miniList" style="display:flex;flex-direction:column;gap:8px;">
        <!-- compact per-round rows inserted here -->
      </div>
    </div>
  </div>

  <!-- Fullscreen Leaderboard View -->
  <div class="leaderboard-view" id="leaderboardView" role="dialog" aria-modal="true">
    <div class="view-header">
      <div class="view-title">Scores — Rounds</div>
      <div class="leaderboard-summary" id="leaderboardSummary">Total Wins: Player A 0 — Player B 0</div>
      <div>
        <button class="back-btn" id="closeFull">Back</button>
      </div>
    </div>
    <div class="leaderboard-grid">
      <div class="leaderboard-col" style="flex:1">
        <h4 style="margin-top:0">Rounds</h4>
        <!-- header: avatars & names -->
        <div id="scoresHeader" style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
          <div style="text-align:left;display:flex;gap:10px;align-items:center">
            <img id="headerAvatarA" src="" style="width:56px;height:56px;border-radius:8px;object-fit:cover;border:2px solid rgba(255,255,255,0.06)" alt="A">
            <div style="font-weight:800" id="headerNameA">Player A</div>
          </div>
          <!-- center is intentionally empty; H4 above is the 'Rounds' label -->
          <div style="text-align:right;display:flex;gap:10px;align-items:center;justify-content:flex-end">
            <div style="font-weight:800" id="headerNameB">Player B</div>
            <img id="headerAvatarB" src="" style="width:56px;height:56px;border-radius:8px;object-fit:cover;border:2px solid rgba(255,255,255,0.06)" alt="B">
          </div>
        </div>
        <div id="fullList" style="display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto"></div>
        <div id="scoresTotals" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.04);"></div>
      </div>
    </div>
  </div>

  <!-- Rules Modal -->
  <div class="modal" id="rulesModal" role="dialog" aria-modal="true" style="display:none">
    <div class="modal-card card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <div style="font-weight:900">Game Rules</div>
        <button class="back-btn" id="closeRules">Close</button>
      </div>
      <div id="rulesContent" style="font-size:14px; color:var(--muted); line-height:1.4">
        <!-- rules injected by JS -->
      </div>
    </div>
  </div>

  <!-- Data & Event Log Modal -->
  <div class="modal" id="dataModal" role="dialog" aria-modal="true" style="display:none">
    <div class="modal-card card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <div style="font-weight:900">Data & Log</div>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="back-btn" id="exportData">Export</button>
          <button class="back-btn" id="importBtn">Import</button>
          <input type="file" id="importFile" accept="application/json" style="display:none">
          <button class="back-btn" id="clearData">Clear</button>
          <button class="back-btn" id="closeData">Close</button>
        </div>
      </div>
      <div style="font-size:13px;color:var(--muted);margin-bottom:8px">Export will download the full game state (JSON). Import will replace the current state if compatible. Logs are preserved unless cleared.</div>
      <div class="backup-panel" id="backupPanel">
        <h4>Automatic backups</h4>
        <label class="backup-toggle">
          <input type="checkbox" id="autoBackupToggle" checked>
          <span>Enable automatic backups (stored in IndexedDB)</span>
        </label>
        <div class="backup-status" id="backupStatusText">Automatic backups are initializing…</div>
        <div class="backup-meta" id="backupMetaText">No backups saved yet.</div>
        <div class="backup-actions">
          <button class="back-btn" id="downloadBackupBtn">Download backup</button>
          <button class="back-btn ghost" id="restoreBackupBtn">Restore backup</button>
        </div>
      </div>
      <div style="max-height:60vh; overflow:auto;">
        <ul id="modalLog" style="list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px"></ul>
      </div>
    </div>
  </div>

  <div class="update-banner" id="updateBanner" role="status" aria-live="polite">
    <div>
      <strong>Update ready</strong>
      <div id="updateBannerText" style="font-size:13px;color:var(--muted);">A new version is available. Refresh to apply the latest fixes.</div>
    </div>
    <div class="update-actions">
      <button class="ghost" id="dismissUpdate">Later</button>
      <button id="refreshUpdate">Refresh</button>
    </div>
  </div>

  <script src="app-version.js"></script>
  <script src="auto-backup.js"></script>
  <script src="migrations/migrate-to-v2.js"></script>
  <script>
    const $=sel=>document.querySelector(sel);
    const state={
      round:1,
      players:{
        A:{name:'Player A',score:0,streak:0,avatar:''},
        B:{name:'Player B',score:0,streak:0,avatar:''}
      },
  // track rounds: {winner:'A'|'B'|'T', scoreA: number, scoreB: number}
  roundWinners:[],
      history:[]
    };

    const AutoBackup = window.AutoBackup || window.PunchBuggyAutoBackup || window.PunchBuggyBackup;
    const versionEl = $('#appVersion');
    if(versionEl){
      versionEl.textContent = window.PUNCHBUGGY_APP_VERSION || '—';
    }

    function render(){
      $('#scoreA').textContent=state.players.A.score;
      $('#scoreB').textContent=state.players.B.score;
      $('#streakA').textContent=`🔥 ${state.players.A.streak}`;
      $('#streakB').textContent=`🔥 ${state.players.B.streak}`;
      $('#nameA').value=state.players.A.name;
      $('#nameB').value=state.players.B.name;
      if(state.players.A.avatar) $('#avatarA').src=state.players.A.avatar;
      if(state.players.B.avatar) $('#avatarB').src=state.players.B.avatar;
      $('#round').textContent=state.round;
  const diff=state.players.A.score-state.players.B.score;
  $('#lead').textContent=diff===0?"Tied":diff>0?`${state.players.A.name} +${diff}`:`${state.players.B.name} +${Math.abs(diff)}`;
      renderLeaderboard();
      // show crown on current leader avatar
      const leader = state.players.A.score === state.players.B.score ? null : (state.players.A.score > state.players.B.score ? 'A' : 'B');
      if(leader==='A'){ $('#crownA').style.display='flex'; $('#crownB').style.display='none'; }
      else if(leader==='B'){ $('#crownB').style.display='flex'; $('#crownA').style.display='none'; }
      else { $('#crownA').style.display='none'; $('#crownB').style.display='none'; }
      renderModalLog();
      save();
    }

    function renderModalLog(){
      const list = $('#modalLog');
      if(!list) return;
      list.innerHTML = state.history.slice().reverse().map(e=>`<li style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.03)">${e}</li>`).join('');
    }

    function renderLeaderboard(){
      // normalize legacy entries (strings) into objects
      const rounds = state.roundWinners.map(r=>{
        if(!r) return null;
        if(typeof r === 'string'){
          // legacy: 'A'|'B'|'T' - we don't have scores, use 0-0 placeholder
          if(r==='A') return {winner:'A', scoreA:0, scoreB:0};
          if(r==='B') return {winner:'B', scoreA:0, scoreB:0};
          return {winner:'T', scoreA:0, scoreB:0};
        }
        return r;
      }).filter(Boolean);

  const currentScore = `${state.players.A.score} — ${state.players.B.score}`;
  const leader = state.players.A.score === state.players.B.score ? 'Tied' : (state.players.A.score > state.players.B.score ? state.players.A.name : state.players.B.name);

      // small card: compact per-round rows
      const mini = $('#miniList');
      mini.innerHTML = '';
      rounds.forEach((r, idx)=>{
        const row = document.createElement('div');
        row.style.display='flex'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.gap='12px';
        row.style.padding='8px'; row.style.borderRadius='10px';
        row.style.background='linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))';
        const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='10px';
        const badge = document.createElement('div'); badge.className='token'; badge.textContent = idx+1; badge.style.width='34px'; badge.style.height='34px'; badge.style.fontSize='14px';
        const title = document.createElement('div'); title.style.fontWeight='700'; title.textContent = r.winner==='T'? 'Tie' : (r.winner==='A'? state.players.A.name : state.players.B.name);
        left.appendChild(badge); left.appendChild(title);
        const score = document.createElement('div'); score.style.fontWeight='800'; score.textContent = `${r.scoreA} — ${r.scoreB}`;
        if(r.winner==='A') row.style.borderLeft='4px solid rgba(93,212,162,0.9)';
        else if(r.winner==='B') row.style.borderLeft='4px solid rgba(138,168,255,0.9)';
        mini.appendChild(row);
        row.appendChild(left); row.appendChild(score);
      });

      // full view: simple scores list (A | Round | B)
      const full = $('#fullList');
      if(full) full.innerHTML = '';
      // totals
      let totalA = 0, totalB = 0, winsA = 0, winsB = 0;
      rounds.forEach((r, idx)=>{
        totalA += r.scoreA; totalB += r.scoreB;
        if(r.winner==='A') winsA++; else if(r.winner==='B') winsB++;

        const row = document.createElement('div');
        row.style.display='grid'; row.style.gridTemplateColumns='1fr auto 1fr'; row.style.alignItems='center';
        row.style.padding='10px 12px'; row.style.borderRadius='10px'; row.style.marginBottom='6px';
        row.style.background='linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))';

        const aCol = document.createElement('div'); aCol.style.textAlign='left'; aCol.style.fontWeight='800'; aCol.style.fontSize='16px';
        aCol.textContent = r.scoreA;
        const mid = document.createElement('div'); mid.style.textAlign='center'; mid.style.color='var(--muted)'; mid.style.fontWeight='700'; mid.textContent = `Round ${idx+1}`;
        const bCol = document.createElement('div'); bCol.style.textAlign='right'; bCol.style.fontWeight='800'; bCol.style.fontSize='16px';
        bCol.textContent = r.scoreB;

        // highlight winning score
        if(r.winner==='A'){
          aCol.style.color = 'var(--gold)'; aCol.style.fontSize='20px';
        } else if(r.winner==='B'){
          bCol.style.color = 'var(--gold)'; bCol.style.fontSize='20px';
        } else { // tie
          aCol.style.color = 'var(--muted)'; bCol.style.color = 'var(--muted)';
        }

        row.appendChild(aCol); row.appendChild(mid); row.appendChild(bCol);
        full.appendChild(row);
      });

      // header avatars & names
      if($('#headerAvatarA')) $('#headerAvatarA').src = state.players.A.avatar || $('#avatarA').src;
      if($('#headerAvatarB')) $('#headerAvatarB').src = state.players.B.avatar || $('#avatarB').src;
      if($('#headerNameA')) $('#headerNameA').textContent = state.players.A.name;
      if($('#headerNameB')) $('#headerNameB').textContent = state.players.B.name;

      // totals area
      const totals = $('#scoresTotals');
      if(totals){
        totals.innerHTML = '';
        const totalsRow = document.createElement('div'); totalsRow.style.display='grid'; totalsRow.style.gridTemplateColumns='1fr auto 1fr'; totalsRow.style.alignItems='center'; totalsRow.style.padding='12px'; totalsRow.style.borderRadius='10px'; totalsRow.style.marginTop='8px'; totalsRow.style.background='linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))';
        const left = document.createElement('div'); left.style.textAlign='left'; left.innerHTML = `<div style="font-size:14px;color:var(--muted)">${state.players.A.name} Total</div><div style="font-weight:900;font-size:18px">${totalA}</div>`;
        const mid = document.createElement('div'); mid.style.textAlign='center'; mid.innerHTML = `<div style="font-size:14px;color:var(--muted)">Rounds</div><div style="font-weight:900;font-size:18px">${rounds.length}</div>`;
        const right = document.createElement('div'); right.style.textAlign='right'; right.innerHTML = `<div style="font-size:14px;color:var(--muted)">Wins</div><div style="font-weight:900;font-size:18px">${state.players.A.name} ${winsA} — ${state.players.B.name} ${winsB}</div>`;
        totalsRow.appendChild(left); totalsRow.appendChild(mid); totalsRow.appendChild(right);
        totals.appendChild(totalsRow);
      }
      // update summary now that totals are available
  $('#leaderboardSummary').innerHTML = `<div style="font-weight:700">Rounds: ${rounds.length} — Live: ${currentScore}</div><div style="font-size:13px;color:var(--muted);margin-top:6px">Wins: ${state.players.A.name} ${winsA} — ${state.players.B.name} ${winsB} &nbsp; • &nbsp; Totals: ${state.players.A.name} ${totalA} — ${state.players.B.name} ${totalB}</div>`;

  // header avatars/names (keep in sync)
  if($('#headerAvatarA')) $('#headerAvatarA').src = state.players.A.avatar || $('#avatarA').src;
  if($('#headerAvatarB')) $('#headerAvatarB').src = state.players.B.avatar || $('#avatarB').src;
  if($('#headerNameA')) $('#headerNameA').textContent = state.players.A.name;
  if($('#headerNameB')) $('#headerNameB').textContent = state.players.B.name;
    }

    function save(){
      localStorage.setItem('punchBuggy',JSON.stringify(state));
      if(AutoBackup && typeof AutoBackup.handleStoreSave==='function'){
        AutoBackup.handleStoreSave('auto');
      }
    }
    function load(){
      const s=localStorage.getItem('punchBuggy');
      if(s){
        const parsed = JSON.parse(s);
        // migrate roundWinners legacy strings to objects
        if(parsed.roundWinners && Array.isArray(parsed.roundWinners)){
          parsed.roundWinners = parsed.roundWinners.map(r=>{
            if(typeof r === 'string'){
              if(r==='A') return {winner:'A',scoreA:0,scoreB:0};
              if(r==='B') return {winner:'B',scoreA:0,scoreB:0};
              return {winner:'T',scoreA:0,scoreB:0};
            }
            return r;
          });
        }
        Object.assign(state,parsed);
      }
      render();
    }

    function log(msg){state.history.push(msg);render();}

    function score(p,d=1){
      const other=p==='A'?'B':'A';
      state.players[p].score=Math.max(0,state.players[p].score+d);

      if(d>0){
        state.players[p].streak++;
        state.players[other].streak=0;

        // Winner animation
        $(`.card[data-player="${p}"]`).classList.add('winner');
        setTimeout(()=>$(`.card[data-player="${p}"]`).classList.remove('winner'),600);

        // Loser animation
        $(`.card[data-player="${other}"]`).classList.add('loser');
        setTimeout(()=>$(`.card[data-player="${other}"]`).classList.remove('loser'),500);

        // Score bump
        $(`#score${p}`).classList.add('bump');
        setTimeout(()=>$(`#score${p}`).classList.remove('bump'),500);

        log(`${state.players[p].name} spotted a bug! +1`);

        // Confetti on milestones
        if(state.players[p].score%5===0) confetti();

        // Extra celebration on first lead takeover
        if(state.players[p].score>state.players[other].score && state.players[p].score-state.players[other].score===1){
          setTimeout(()=>confetti(),200);
        }
      } else {
        state.players[p].streak=0;
        log(`${state.players[p].name} correction: -1`);
      }

      render();
    }

    function reset(){
      if(confirm('Reset entire game? This will also clear round history.')){
        state.round=1;
        Object.values(state.players).forEach(p=>{p.score=0;p.streak=0});
        state.history=[];
        state.roundWinners=[];
        render();
      }
    }

    function undo(){if(state.history.length>0)state.history.pop();render();}
    function recordRoundWinner(){
      const a=state.players.A.score; const b=state.players.B.score;
      let win='T';
      if(a>b) win='A'; else if(b>a) win='B';
      state.roundWinners.push({ winner: win, scoreA: a, scoreB: b });
      if(win==='T') log(`🤝 Round ${state.round} tied ${a}-${b}`);
      else if(win==='A') log(`🏆 ${state.players.A.name} won Round ${state.round} ${a}-${b}`);
      else log(`🏆 ${state.players.B.name} won Round ${state.round} ${b}-${a}`);
    }

    function nextRound(){
      // record current winner, then bump round and reset scores
      recordRoundWinner();
      state.round++;
      Object.values(state.players).forEach(p=>{p.score=0;p.streak=0});
      log(`🏁 Round ${state.round} started!`);
      render();
    }

    function confetti(){
      const root=$('#confetti');
      root.innerHTML='';
      for(let i=0;i<50;i++){
        const d=document.createElement('div');
        d.className='piece';
        d.style.left=Math.random()*100+'%';
        d.style.top='-10px';
        d.style.background=['#5be2b0','#8aa8ff','#ffd166','#ff6b6b'][Math.floor(Math.random()*4)];
        d.style.transform=`rotate(${Math.random()*360}deg)`;
        root.appendChild(d);
        d.animate([
          {top:'-10px',opacity:1},
          {top:'110%',opacity:0}
        ],{duration:1500+Math.random()*1000,easing:'cubic-bezier(.25,.46,.45,.94)'});
        setTimeout(()=>d.remove(),3000);
      }
    }

    function handleImageUpload(player,file){
      if(!file||!file.type.startsWith('image/'))return;
      const reader=new FileReader();
      reader.onload=e=>{
        state.players[player].avatar=e.target.result;
        render();
      };
      reader.readAsDataURL(file);
    }

    $('#btnA').onclick=()=>score('A',1);
    $('#btnB').onclick=()=>score('B',1);
    $('#minusA').onclick=()=>score('A',-1);
    $('#minusB').onclick=()=>score('B',-1);
    $('#resetBtn').onclick=reset;
    $('#undoBtn').onclick=undo;
    $('#nextRound').onclick=nextRound;
    // bottom nav and leaderboard controls
    function toggleLeaderboard(show){
      const wrap = $('#leaderboardWrap');
      wrap.style.display = show? 'block' : 'none';
    }

    $('#clearBoard').onclick=()=>{ if(confirm('Clear round history?')){ state.roundWinners=[]; render(); } };
    $('#closeBoard').onclick=()=>toggleLeaderboard(false);
    // fullscreen leaderboard controls
    function openFullLeaderboard(){
      document.body.style.overflow='hidden';
      $('#leaderboardView').style.display='block';
      renderLeaderboard();
    }
    function closeFullLeaderboard(){
      document.body.style.overflow='auto';
      $('#leaderboardView').style.display='none';
    }
    $('#leaderboardBtn').onclick=()=>openFullLeaderboard();
    $('#closeFull').onclick=()=>closeFullLeaderboard();
    // Rules content (concise, comprehensive)
    const rules = [
      'Objective: Spot the VW Beetle (or other agreed target) first to score a point.',
      'Scoring: First player to call it gets +1. Use the correction (-1) for false calls.',
      'Rounds: Press Next Round to record the round winner and start fresh scores for the next round.',
      'Streaks: Consecutive correct calls increase your streak but do not change round scoring.',
      'Safety: Keep your eyes on the road. No taking photos or reaching for phones while driving.',
      'Fair Play: Disputes are resolved by mutual agreement; use -1 for honest corrections.',
      'Milestones: Every 5 points triggers a celebration (confetti).',
      'Tie Rounds: If both players have equal scores when Next Round is pressed, the round is recorded as a tie.',
      'Customization: Change player names or avatars before/after rounds. Avatars are local only.'
    ];
    $('#rulesBtn').onclick=()=>{
      const el = $('#rulesContent');
      el.innerHTML = '<ol style="margin:0;padding-left:18px">' + rules.map(r=>`<li style="margin-bottom:8px">${r}</li>`).join('') + '</ol>';
      $('#rulesModal').style.display='flex';
    };

    // Data modal handlers (export/import/log/clear)
    $('#dataBtn').onclick=()=>{ $('#dataModal').style.display='flex'; renderModalLog(); if(typeof updateBackupUi==='function'){ updateBackupUi(AutoBackup && AutoBackup.getStatus ? AutoBackup.getStatus() : {code:'unsupported'}); } };
    $('#closeData').onclick=()=>{ $('#dataModal').style.display='none'; };
    $('#clearData').onclick=()=>{ if(confirm('Clear all game data (rounds, scores, history)?')){ state.round=1; state.players.A.score=0; state.players.B.score=0; state.players.A.streak=0; state.players.B.streak=0; state.history=[]; state.roundWinners=[]; render(); } };

    // Export state as JSON file
    $('#exportData').onclick=()=>{
      const payload = JSON.stringify(state, null, 2);
      const blob = new Blob([payload], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download = `punchbuggy-export-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };

    // Import - parse file and normalize various export shapes (supports older shape and `rounds`-style exports)
    function normalizeImportedState(parsed){
      if(!parsed || typeof parsed !== 'object') return { error: 'invalid' };

      const out = {};
      // Players: support both flat {players.A.score} and nested {players.A.current.score}
      out.players = {
        A: { name: 'Player A', score: 0, streak: 0, avatar: '' },
        B: { name: 'Player B', score: 0, streak: 0, avatar: '' }
      };

      if(parsed.players && typeof parsed.players === 'object'){
        ['A','B'].forEach(k=>{
          const p = parsed.players[k] || {};
          const name = typeof p.name === 'string' && p.name.trim() ? p.name.trim() : out.players[k].name;
          const avatar = typeof p.avatar === 'string' ? p.avatar : '';
          let score = 0, streak = 0;
          if(p.current && typeof p.current === 'object'){
            score = Number(p.current.score) || 0;
            streak = Number(p.current.streak) || 0;
          } else {
            score = Number(p.score) || 0;
            streak = Number(p.streak) || 0;
          }
          out.players[k] = { name, score, streak, avatar };
        });
      }

      // Round number: prefer top-level `round`, fallback to `rounds.current.number`
      if(Number.isFinite(Number(parsed.round))) out.round = Math.max(1, Math.round(Number(parsed.round)));
      else if(parsed.rounds && parsed.rounds.current && Number.isFinite(Number(parsed.rounds.current.number))) out.round = Math.max(1, Math.round(Number(parsed.rounds.current.number)));
      else out.round = 1;

      // Round winners: try to map from `rounds.history` if present, otherwise use roundWinners if available
      out.roundWinners = [];
      if(parsed.rounds && Array.isArray(parsed.rounds.history)){
        out.roundWinners = parsed.rounds.history.map(r=>{
          const winner = r && r.winner ? r.winner : 'T';
          const scoreA = r && r.scores && Number.isFinite(Number(r.scores.A)) ? Number(r.scores.A) : 0;
          const scoreB = r && r.scores && Number.isFinite(Number(r.scores.B)) ? Number(r.scores.B) : 0;
          return { winner, scoreA, scoreB };
        });
      } else if(Array.isArray(parsed.roundWinners)){
        out.roundWinners = parsed.roundWinners.map(r=>{
          if(typeof r === 'string'){
            if(r === 'A') return { winner: 'A', scoreA: 0, scoreB: 0 };
            if(r === 'B') return { winner: 'B', scoreA: 0, scoreB: 0 };
            return { winner: 'T', scoreA: 0, scoreB: 0 };
          }
          return r;
        }).filter(Boolean);
      }

      // History: accept array of log objects or strings
      if(Array.isArray(parsed.history)){
        out.history = parsed.history.map(h=>{
          if(typeof h === 'string') return h;
          if(h && h.message) return h.message;
          try{ return JSON.stringify(h); }catch(e){ return String(h); }
        });
      } else {
        out.history = [];
      }

      // optional: preserve schemaVersion if present
      if(parsed.schemaVersion) out.schemaVersion = parsed.schemaVersion;

      return out;
    }

    $('#importBtn').onclick=()=>$('#importFile').click();
    $('#importFile').onchange = async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        const text = await f.text();
        const parsed = JSON.parse(text);
        const normalized = normalizeImportedState(parsed);
        if(normalized && normalized.error){ alert('Invalid file: could not parse import'); e.target.value=''; return; }
        if(!confirm('Importing will replace your current game state. Continue?')) { e.target.value=''; return; }
        Object.assign(state, normalized);
        render();
        alert('Import successful');
      }catch(err){ alert('Failed to import: ' + (err && err.message ? err.message : String(err))); }
      e.target.value='';
    };

    const backupStatusEl = $('#backupStatusText');
    const backupMetaEl = $('#backupMetaText');
    const autoBackupToggle = $('#autoBackupToggle');
    const downloadBackupBtn = $('#downloadBackupBtn');
    const restoreBackupBtn = $('#restoreBackupBtn');

    function describeBackupIso(iso){
      if(!iso) return null;
      const date = new Date(iso);
      if(Number.isNaN(date.getTime())) return null;
      const diff = Date.now() - date.getTime();
      if(diff < 30 * 1000) return 'just now';
      if(diff < 60 * 60 * 1000){
        const mins = Math.round(diff / 60000);
        return `${mins} minute${mins===1?'':'s'} ago`;
      }
      if(diff < 24 * 60 * 60 * 1000){
        const hours = Math.round(diff / 3600000);
        return `${hours} hour${hours===1?'':'s'} ago`;
      }
      return date.toLocaleString();
    }

    function updateBackupUi(status){
      if(!backupStatusEl) return;
      const data = status || {};
      const metadata = data.metadata || {};
      if(typeof data.enabled === 'boolean' && autoBackupToggle){
        autoBackupToggle.checked = data.enabled;
      }
      backupStatusEl.textContent = data.message || (data.enabled === false ? 'Automatic backups are disabled.' : 'Automatic backups ready.');
      if(backupMetaEl){
        const details = [];
        if(data.code === 'unsupported'){
          details.push('This browser does not support IndexedDB-based backups.');
        }else{
          if(metadata.currentBackupDate){
            const desc = describeBackupIso(metadata.currentBackupDate);
            if(desc) details.push(`Current backup saved ${desc}`);
          }
          if(metadata.previousBackupDate){
            const desc = describeBackupIso(metadata.previousBackupDate);
            if(desc) details.push(`Previous backup saved ${desc}`);
          }
          if(metadata.oldestBackupDate){
            const desc = describeBackupIso(metadata.oldestBackupDate);
            if(desc) details.push(`Oldest backup saved ${desc}`);
          }
          if(!metadata.currentBackupDate && data.enabled !== false){
            details.push('No backups have been created yet.');
          }
          if(data.code === 'error' && data.error){
            const errText = data.error && data.error.message ? data.error.message : String(data.error);
            details.push(`Error: ${errText}`);
          }
        }
        backupMetaEl.textContent = details.join(' • ');
      }
      const disabled = data.code === 'unsupported' || data.enabled === false;
      if(downloadBackupBtn) downloadBackupBtn.disabled = disabled;
      if(restoreBackupBtn) restoreBackupBtn.disabled = disabled || !(metadata.backupCount > 0);
    }

    function applyRestoredState(snapshot){
      if(!snapshot || typeof snapshot !== 'object') return;
      const defaults = {
        round: 1,
        players: {
          A: { name: 'Player A', score: 0, streak: 0, avatar: '' },
          B: { name: 'Player B', score: 0, streak: 0, avatar: '' }
        },
        roundWinners: [],
        history: []
      };
      const next = Object.assign({}, defaults, snapshot);
      const nextPlayers = snapshot && snapshot.players ? snapshot.players : {};
      next.players = Object.assign({}, defaults.players, nextPlayers);
      next.players.A = Object.assign({}, defaults.players.A, nextPlayers.A || {});
      next.players.B = Object.assign({}, defaults.players.B, nextPlayers.B || {});
      next.roundWinners = Array.isArray(snapshot && snapshot.roundWinners) ? snapshot.roundWinners.slice() : [];
      next.history = Array.isArray(snapshot && snapshot.history) ? snapshot.history.slice() : [];
      Object.assign(state, next);
      render();
    }

    if(!AutoBackup || !AutoBackup.SUPPORTED){
      updateBackupUi({ code:'unsupported', message:'Automatic backups are unavailable in this browser.', enabled:false });
      if(autoBackupToggle) autoBackupToggle.disabled = true;
      if(downloadBackupBtn) downloadBackupBtn.disabled = true;
      if(restoreBackupBtn) restoreBackupBtn.disabled = true;
    }else{
      if(autoBackupToggle){
        autoBackupToggle.addEventListener('change', e=>{
          try{
            AutoBackup.setEnabled(e.target.checked);
          }catch(err){
            console.error('AutoBackup toggle failed', err);
            e.target.checked = !e.target.checked;
          }
        });
      }
      if(downloadBackupBtn){
        downloadBackupBtn.onclick = async ()=>{
          try{
            await AutoBackup.manualBackup();
          }catch(err){
            console.error('Manual backup failed', err);
            alert('Failed to download backup: ' + (err && err.message ? err.message : err));
          }
        };
      }
      if(restoreBackupBtn){
        restoreBackupBtn.onclick = async ()=>{
          try{
            const backups = await AutoBackup.listBackups();
            if(!backups.length){
              alert('No backups available to restore yet.');
              return;
            }
            const labels = { current: 'Current', previous: 'Previous', oldest: 'Oldest' };
            const options = backups.map((item, idx)=>{
              const desc = describeBackupIso(item.savedAt) || item.savedAt || 'unknown time';
              return `${idx+1}. ${labels[item.key] || item.key} — saved ${desc}`;
            });
            const choice = prompt(`Restore which backup?\n${options.join('\n')}\nEnter a number:`, '1');
            if(!choice) return;
            const index = parseInt(choice,10) - 1;
            if(Number.isNaN(index) || index < 0 || index >= backups.length){
              alert('Invalid selection.');
              return;
            }
            const selected = backups[index];
            const when = describeBackupIso(selected.savedAt) || selected.savedAt || 'an unknown time';
            if(!confirm(`Restore the ${labels[selected.key] || selected.key} backup from ${when}? This will replace your current game data.`)) return;
            await AutoBackup.restoreFromBackup(selected.key);
            alert('Backup restored successfully.');
          }catch(err){
            console.error('Restore backup failed', err);
            alert('Failed to restore backup: ' + (err && err.message ? err.message : err));
          }
        };
      }
      AutoBackup.init({ getState: ()=>state, applyState: applyRestoredState, onStatusChange: updateBackupUi });
      updateBackupUi(AutoBackup.getStatus());
    }
    $('#closeRules').onclick=()=>{ $('#rulesModal').style.display='none'; };
    $('#nameA').onchange=e=>{state.players.A.name=e.target.value;render()};
    $('#nameB').onchange=e=>{state.players.B.name=e.target.value;render()};
    $('#uploadA').onchange=e=>handleImageUpload('A',e.target.files[0]);
    $('#uploadB').onchange=e=>handleImageUpload('B',e.target.files[0]);

    function setupServiceWorkerUpdates(){
      if(!('serviceWorker' in navigator)) return;
      // Dev flag: set to `false` to require manual refresh. Set to `true` to re-enable auto-apply.
      // Default intentionally `false` so users must click Refresh to apply updates.
      window.PUNCHBUGGY_AUTO_APPLY_UPDATES = window.PUNCHBUGGY_AUTO_APPLY_UPDATES === undefined ? false : !!window.PUNCHBUGGY_AUTO_APPLY_UPDATES;
      
      const banner = $('#updateBanner');
      const bannerText = $('#updateBannerText');
      const refreshBtn = $('#refreshUpdate');
      const dismissBtn = $('#dismissUpdate');
      const root = document.documentElement;
      let waitingWorker = null;
      let autoReloadTimer = null;
      let refreshing = false;

      function applyBannerOffset(){
        if(!banner || banner.style.display === 'none') return;
        const update = ()=>{
          const height = banner.getBoundingClientRect().height || 0;
          if(root) root.style.setProperty('--update-banner-offset', `${Math.ceil(height + 16)}px`);
        };
        if(window.requestAnimationFrame){
          requestAnimationFrame(()=>requestAnimationFrame(update));
        }else{
          setTimeout(update,0);
        }
      }

      function hideBanner(){
        if(autoReloadTimer) clearTimeout(autoReloadTimer);
        autoReloadTimer = null;
        if(banner) banner.style.display = 'none';
        waitingWorker = null;
        if(root) root.style.setProperty('--update-banner-offset','0px');
      }

      function requestRefresh(){
        if(waitingWorker){
          const worker = waitingWorker;
          // mark that a refresh was explicitly requested so controllerchange will reload
          refreshing = true;
          hideBanner();
          worker.postMessage({type:'SKIP_WAITING'});
        }
      }

      function showBanner(worker){
        waitingWorker = worker;
        if(!banner) return;
        if(bannerText){
          const version = window.PUNCHBUGGY_APP_VERSION || 'latest';
          bannerText.textContent = `Version ${version} is ready. Refresh to load the latest updates.`;
        }
        banner.style.display = 'flex';
        applyBannerOffset();
        if(autoReloadTimer) clearTimeout(autoReloadTimer);
        // Only schedule auto-apply when explicitly enabled.
        if(window.PUNCHBUGGY_AUTO_APPLY_UPDATES){
          autoReloadTimer = setTimeout(()=>{
            if(waitingWorker){
              requestRefresh();
            }
          }, 30000);
        } else {
          autoReloadTimer = null;
        }
      }

      if(refreshBtn) refreshBtn.onclick=()=>requestRefresh();
      if(dismissBtn) dismissBtn.onclick=()=>hideBanner();
      window.addEventListener('resize', applyBannerOffset);

      // Debug helper: allow manual banner show from console during testing.
      // Usage: window.DEBUG_showUpdateBanner('Optional message');
      window.DEBUG_showUpdateBanner = function(versionText){
        try{
          if(!banner) return;
          if(bannerText) bannerText.textContent = versionText || `Version ${window.PUNCHBUGGY_APP_VERSION || 'latest'} is ready. Refresh to load the latest updates.`;
          banner.style.display = 'flex';
          applyBannerOffset();
        }catch(err){ console.warn('DEBUG_showUpdateBanner failed', err); }
      };

      navigator.serviceWorker.addEventListener('controllerchange', () => {
        // Only reload the page when we explicitly requested the refresh (refreshing === true).
        if(!refreshing) return;
        // proceed with reload
        window.location.reload();
      });

      navigator.serviceWorker.register('/service-worker.js').then(reg=>{
        if(reg.waiting){
          showBanner(reg.waiting);
        }
        reg.addEventListener('updatefound', ()=>{
          const newWorker = reg.installing;
          if(!newWorker) return;
          newWorker.addEventListener('statechange', ()=>{
            if(newWorker.state === 'installed' && navigator.serviceWorker.controller){
              showBanner(newWorker);
            }
          });
        });
        setInterval(()=>{
          if(document.visibilityState === 'visible'){
            reg.update();
          }
        }, 5 * 60 * 1000);
      }).catch(err=>{
        console.error('Service worker registration failed:', err);
      });
    }

    // Run in-app migration if needed (creates a backup key in localStorage)
    try{
      if(window.PunchBuggyMigrations && typeof window.PunchBuggyMigrations.migrateIfNeeded === 'function'){
        const result = window.PunchBuggyMigrations.migrateIfNeeded();
        if(result && result.migrated){
          // notify user in data modal log and backup UI
          const logEl = document.getElementById('modalLog');
          if(logEl) logEl.insertAdjacentHTML('beforeend', `<li>Migrated local data to schema v2.0.0 — backup key: ${result.backupKey || 'unknown'}</li>`);
          const backupMeta = document.getElementById('backupMetaText');
          if(backupMeta && result.backupKey){ backupMeta.textContent = `A backup was created: ${result.backupKey}`; }
        }
      }
    }catch(err){ console.error('Migration call failed', err); }

    load();
    setupServiceWorkerUpdates();
  </script>
</body>
</html>
